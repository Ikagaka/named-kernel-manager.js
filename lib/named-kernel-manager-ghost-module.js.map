{"version":3,"sources":["lib/named-kernel-manager-ghost-module.js"],"names":[],"mappings":"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","file":"named-kernel-manager-ghost-module.js","sourcesContent":["import {Shiorif} from 'shiorif';\r\nimport {GhostKernel} from 'ghost-kernel';\r\nimport {NamedKernelManager} from './named-kernel-manager';\r\n\r\nexport class NamedKernelManagerGhostModule {\r\n  /**\r\n   * デフォルトのゴーストのビュークラス\r\n   * @type {cuttlebone}\r\n   */\r\n  static get GhostViewClass() { return NamedKernelManager._GhostViewClass; }\r\n\r\n  /**\r\n   * デフォルトのゴーストのビュークラス\r\n   * @type {cuttlebone}\r\n   */\r\n  static set GhostViewClass(value) { NamedKernelManager._GhostViewClass = value; }\r\n\r\n  /**\r\n   * ゴーストのビュークラス\r\n   * @type {cuttlebone}\r\n   */\r\n  get GhostViewClass() { return this._GhostViewClass || NamedKernelManager._GhostViewClass; }\r\n\r\n  /**\r\n   * ゴーストのビュークラス\r\n   * @type {cuttlebone}\r\n   */\r\n  set GhostViewClass(value) { this._GhostViewClass = value; }\r\n\r\n  /**\r\n   * load ghost\r\n   * @param {string} namedId - named id\r\n   * @param {GhostProfile} [profile] - profile\r\n   * @param {RoutableComponentRoutes} [routes] - ルーティング\r\n   * @param {Hash<GhostKernelController>} [controllers] - コントローラ\r\n   * @param {cuttlebone} [GhostViewClass] ghost view class\r\n   * @return {Promise<GhostKernel>} ghost kernel instance\r\n   */\r\n  async loadGhost(namedId, profile, routes, controllers, GhostViewClass) {\r\n    if (this.isKernelExists(namedId)) {\r\n      throw new Error(`ghost [${namedId}] already exists`);\r\n    }\r\n\r\n    const kernel = await this._getGhostKernelAsProfile(namedId, profile, routes, controllers, GhostViewClass);\r\n    this.registerKernel(namedId, kernel);\r\n    return kernel;\r\n  }\r\n\r\n  /**\r\n   * load ghost\r\n   * @param {string} namedId - named id\r\n   * @param {GhostProfile} [profile] - profile\r\n   */\r\n  async _get_ghost_profile(namedId, profile) {\r\n    return profile || await this.storage.ghost_profile(namedId);\r\n  }\r\n\r\n  /**\r\n   * load ghost\r\n   * @param {string} namedId - named id\r\n   * @param {GhostProfile} [profile] - profile\r\n   * @param {RoutableComponentRoutes} [routes] - ルーティング\r\n   * @param {Hash<GhostKernelController>} [controllers] - コントローラ\r\n   * @param {cuttlebone} [GhostViewClass] ghost view class\r\n   */\r\n  async _getGhostKernelAsProfile(namedId, profile, routes, controllers, GhostViewClass) {\r\n    const _profile = await this._get_ghost_profile(namedId, defaultProfile);\r\n    return await this._get_ghost_kernel(namedId, _profile.shell_name, _profile.balloon_name, routes, controllers, GhostViewClass);\r\n  }\r\n\r\n  /**\r\n   * build ghost kernel\r\n   * @param {string} namedId - named id\r\n   * @param {string} shellname - shellname\r\n   * @param {string} balloonname - balloonname\r\n   * @param {RoutableComponentRoutes} [routes] - ルーティング\r\n   * @param {Hash<GhostKernelController>} [controllers] - コントローラ\r\n   * @param {cuttlebone} [GhostViewClass] ghost view class\r\n   * @return {Promise<GhostKernel>} ghost kernel instance\r\n   */\r\n  async _get_ghost_kernel(namedId, shellname, balloonname, routes, controllers, GhostViewClass) {\r\n    return Promise.all([\r\n      this._get_ghost(namedId, storage),\r\n      this._get_shell(namedId, shellname, storage, GhostViewClass),\r\n      this._get_balloon(balloonname, storage, GhostViewClass),\r\n    ]).then(\r\n      ([shiori, shell, balloon]) => {\r\n        const shiorif = new Shiorif(shiori);\r\n        const named = namedmanager.materialize2(shell, balloon);\r\n        return new GhostKernel({\r\n          Shiorif: shiorif,\r\n          Named: named,\r\n          NamedKernelManager: this,\r\n          TimerEventSource: this.components.TimerEventSource,\r\n        }, routes, controllers);\r\n      }\r\n    )\r\n  }\r\n\r\n  /**\r\n   * ensure path separator at dirpath' end\r\n   * @param {string} dirpath - dirpath\r\n   * @return {string} dirpath that ends with path separator\r\n   */\r\n  static _canondirpath(dirpath) {\r\n    const path_separator = dirpath.match(/[\\\\\\/]/)[0];\r\n    return dirpath.replace(\r\n      new RegExp('\\\\' + path_separator + '?$'),\r\n      path_separator\r\n    );\r\n  }\r\n\r\n  /**\r\n   * get ghost(shiori) instance\r\n   * @param {string} namedId - named id\r\n   * @return {Promise<Shiori>} ghost(shiori) instance\r\n   */\r\n  async _get_ghost(namedId) {\r\n    this.emit('ghost_load', namedId);\r\n    const dirpath = NamedKernelManager._get_ghost_directory_path(namedId);\r\n    const ghost = await NamedKernelManager._load_ghost(storage.backend.fs, dirpath);\r\n    this.emit('ghost_loaded', namedId);\r\n    return ghost;\r\n  }\r\n\r\n  /**\r\n   * get ghost directory path\r\n   * @param {string} namedId - named id\r\n   * @return {string} ghost directory path\r\n   */\r\n  static _get_ghost_directory_path(namedId) {\r\n    return NamedKernelManager._canondirpath(this.storage.ghost_master_path(namedId));\r\n  }\r\n\r\n  /**\r\n   * load ghost(shiori)\r\n   * @param {NanikaDirectory} ghost directory contents\r\n   * @return {Promise<Shiori>} ghost(shiori) instance\r\n   */\r\n  static async _load_ghost(fs, dirpath) {\r\n    const shiori = await ShioriLoader.detect_shiori(fs, dirpath);\r\n    return await shiori.load(dirpath);\r\n  }\r\n\r\n  /**\r\n   * get shell instance\r\n   * @param {string} namedId - named id\r\n   * @param {string} shellname - shellname\r\n   * @param {cuttlebone} [GhostViewClass] ghost view class\r\n   * @return {Promise<Shell>} shell instance\r\n   */\r\n  async _get_shell(namedId, shellname, GhostViewClass) {\r\n    this.emit('load_shell_files', namedId, shellname);\r\n    const directory = await this._get_shell_directory(namedId, shellname);\r\n    this.emit('shell_load', namedId, shellname, directory);\r\n    const shell = await NamedKernelManager._load_shell(directory, GhostViewClass);\r\n    this.emit('shell_loaded', namedId, shellname, shell);\r\n    return shell;\r\n  }\r\n\r\n  /**\r\n   * get shell directory contents\r\n   * @param {string} namedId - named id\r\n   * @param {string} shellname - shellname\r\n   * @return {Promise<NanikaDirectory>} shell directory contents\r\n   */\r\n  async _get_shell_directory(namedId, shellname) {\r\n    return await this.storage.shell(namedId, shellname);\r\n  }\r\n\r\n  /**\r\n   * load shell\r\n   * @param {NanikaDirectory} shell directory contents\r\n   * @param {cuttlebone} [GhostViewClass] ghost view class\r\n   * @return {Promise<Shell>} shell instance\r\n   */\r\n  static _load_shell(directory, GhostViewClass = this.GhostViewClass) {\r\n    const shell = new GhostViewClass.Shell(directory.asArrayBuffer());\r\n    return shell.load();\r\n  }\r\n\r\n  /**\r\n   * get balloon instance\r\n   * @param {string} balloonname - balloonname\r\n   * @param {cuttlebone} [GhostViewClass] ghost view class\r\n   * @return {Promise<Balloon>} balloon instance\r\n   */\r\n  async _get_balloon(balloonname, GhostViewClass) {\r\n    this.emit('load_balloon_files', balloonname);\r\n    const directory = await this._get_balloon_directory(balloonname);\r\n    this.emit('balloon_load', balloonname, directory);\r\n    const balloon = await NamedKernelManager._load_balloon(directory, GhostViewClass);\r\n    this.emit('balloon_loaded', balloonname, shell);\r\n    return balloon;\r\n  }\r\n\r\n  /**\r\n   * get balloon directory contents\r\n   * @param {string} balloonname - balloonname\r\n   * @return {Promise<NanikaDirectory>} balloon directory contents\r\n   */\r\n  async _get_balloon_directory(balloonname) {\r\n    return await this.storage.balloon(balloonname);\r\n  }\r\n\r\n  /**\r\n   * load balloon\r\n   * @param {NanikaDirectory} balloon directory contents\r\n   * @param {cuttlebone} [GhostViewClass] ghost view class\r\n   * @return {Promise<Balloon>} balloon instance\r\n   */\r\n  static _load_balloon(directory, GhostViewClass = this.GhostViewClass) {\r\n    const balloon = new GhostViewClass.Balloon(directory.asArrayBuffer());\r\n    return balloon.load();\r\n  }\r\n\r\n  /**\r\n   * install named\r\n   * @param {Blob | URL | string} target install target resource (file, url or some)\r\n   * @param {NamedKernel | string} [from] who handled the target? kernel or named id\r\n   * @return {Promise}\r\n   */\r\n  async installNar(target, from = null) {\r\n    const nanikaStorage = this.components.NanikaStorage;\r\n    this.emit('install_begin', target);\r\n    let nar;\r\n    try {\r\n      if (target instanceof Blob) {\r\n        nar = await NarLoader.loadFromBlob(target);\r\n      } else if (target instanceof URL || target instanceof String || typeof target === 'string') {\r\n        nar = await NarLoader.loadFromURL(target);\r\n      } else {\r\n        throw new Error(`target is not Blob or URL : ${target.name || target}`); // TODO: typed error\r\n      }\r\n      this.emit('install_nar_loaded', target, nar);\r\n      const dirpath = typeof from === 'string' || from instanceof String ? from : this.namedId(from);\r\n      // TODO: fromの他形式対応\r\n      const sakuraname = nanikaStorage.ghost_descript(dirpath)['sakura.name']\r\n      const install_results = await nanikaStorage.install_nar(nar, dirpath, sakuraname);\r\n      if (!install_results) {\r\n        this.emit('install_not_accepted', target, nar);\r\n        return;\r\n      }\r\n      let ghost_result, balloon_result;\r\n      install_results.forEach((install_result) => {\r\n        if (install_result.type === 'ghost') {\r\n          ghost_result = install_result;\r\n        } else if (install_result.type === 'balloon') {\r\n          balloon_result = install_result;\r\n        }\r\n      });\r\n      if (ghost_result) {\r\n        // 初期profileを設定\r\n        // TODO: vanish回数など\r\n        const profile = await nanikaStorage.ghost_profile(ghost_result.directory);\r\n        if (!profile.shellname) profile.shellname = 'master';\r\n        if (!profile.balloonname) {\r\n          if (balloon_result) {\r\n            // 同梱バルーンを初期設定\r\n            profile.balloonname = balloon_result.directory;\r\n          } else {\r\n            profile.balloonname = 'origin'; // TODO: 設定を読む\r\n          }\r\n        }\r\n        await nanikaStorage.ghost_profile(ghost_result.directory, profile);\r\n      }\r\n      this.emit('install_succeed', target, nar);\r\n    } catch (error) {\r\n      this.emit('install_failure', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n"]}