{"version":3,"sources":["lib/named-kernel-manager.js"],"names":[],"mappings":"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","file":"named-kernel-manager.js","sourcesContent":["import mixin from './mixin';\nimport {RoutableComponent, RoutableComponentRoutes} from 'routable-component';\n\n/**\n * ルーティング設定クラスのリスト\n * @type {RoutableComponentRouting[]}\n */\nexport const NamedKernelManagerRoutings = [];\n\n/**\n * コントローラクラスの連想配列\n * @type {Hash<NamedKernelManagerController>}\n */\nexport const NamedKernelManagerControllers = {};\n\n/** Ukagaka baseware named manager */\nexport class NamedKernelManager extends RoutableComponent {\n  /**\n   * constructor\n   * @param {Object} components - Event source\n   * @param {NanikaStorage} components.NanikaStorage - storage\n   * @param {NamedManager} components.NamedManager - named manager\n   * @param {TimerEventSource} components.TimerEventSource - Timer event source\n   * @param {RoutableComponentRoutes} [routes] - ルーティング\n   * @param {Hash<NamedKernelManagerController>} [controllers_classes] - コントローラ\n   */\n  constructor(components, routes = new RoutableComponentRoutes(NamedKernelManagerRoutings), controllerClasses = NamedKernelManagerControllers) {\n    super(components, routes, controllerClasses);\n    this.registerComponent('NamedKernelManager', this);\n\n    /** @type {NamedKernel[]} */\n    this._namedKernels = {};\n  }\n\n  /**\n   * start manager (emits start event)\n   * @return {void}\n   */\n  async start() {\n    this.emit('start');\n  }\n\n  /**\n   * close manager (emits close event)\n   * @return {void}\n   */\n  async close() {\n    this.emit('close');\n  }\n\n  profile(newProfile) {\n    return this.components.NanikaStorage.base_profile(newProfile);\n  }\n\n  /**\n   * existing named ids\n   * @return {Array<string>} named ids\n   */\n  namedIds() {\n    return Object.keys(this._namedKernels);\n  }\n\n  /**\n   * named instance exists or not\n   * @param {string} namedId - named id\n   * @return {boolean} exists or not\n   */\n  isKernelExists(namedId) {\n    // in や [] 等ではprototypeのものも認識するため\n    return this._namedKernels.hasOwnProperty(namedId);\n  }\n\n  /**\n   * named kernel instance\n   * @param {string} namedId - named id\n   * @return {NamedKernel} named instance\n   */\n  kernel(namedId) {\n    return this.isKernelExists(namedId) ? this._namedKernels[namedId].kernel : null;\n  }\n\n  /**\n   * find named id of a kernel\n   * @param {NamedKernel} kernel - named kernel\n   * @return {string} named id\n   */\n  namedId(kernel) {\n    return Object.keys(this._namedKernels).find((namedId) => this.kernel(namedId) === kernel);\n  }\n\n  /**\n   * register named kernel\n   * @param {string} namedId - named id\n   * @param {NamedKernel} kernel - kernel\n   * @return {NamedKernel} kernel\n   */\n  registerKernel(namedId, kernel) {\n    if (this.isKernelExists(namedId)) {\n      throw new Error(`kernel [${namedId}] already exists`);\n    }\n    this._namedKernels[namedId] = kernel;\n    this.emit('kernel_registered', namedId);\n    return kernel;\n  }\n\n  /**\n   * unregister named kernel\n   * @param {string} namedId - named id\n   * @return {void}\n   */\n  unregisterKernel(namedId) {\n    if (!this.isKernelExists(namedId)) {\n      throw new Error(`kernel [${namedId}] not exists`);\n    }\n    delete this._namedKernels[namedId];\n    this.emit('kernel_unregistered', namedId);\n  }\n\n  /**\n   * send communication\n   * @param {string} fromId - from named id\n   * @param {string} toId - to named id\n   * @param {any} content - communication content\n   * @return {Promise<transactionlike>} transaction\n   */\n  sendCommunication(fromId, toId, content) {\n  }\n\n  /**\n   * send notice\n   * @param {string} fromId - from named id\n   * @param {string} toId - to named id\n   * @param {any} content - communication content\n   * @return {Promise<transactionlike>} transaction\n   */\n  sendNotice(fromId, toId, content) {\n    // other close etc\n  }\n\n  /**\n   * install named\n   * @param {any} target install target resource (file, url or some)\n   * @param {NamedKernel} from who handled the target?\n   * @return {Promise<any>}\n   */\n  async installNamed(target, from) {\n    // TODO: 他形式対応\n    return await this.installNar(target, from);\n  }\n}\n\nimport {Shiorif} from 'shiorif';\nimport {GhostKernel} from 'ghost-kernel';\n\nexport class NamedKernelManagerGhostModule {\n  /**\n   * デフォルトのゴーストのビュークラス\n   * @type {cuttlebone}\n   */\n  static get GhostViewClass() { return NamedKernelManager._GhostViewClass; }\n\n  /**\n   * デフォルトのゴーストのビュークラス\n   * @type {cuttlebone}\n   */\n  static set GhostViewClass(value) { NamedKernelManager._GhostViewClass = value; }\n\n  /**\n   * ゴーストのビュークラス\n   * @type {cuttlebone}\n   */\n  get GhostViewClass() { return this._GhostViewClass || NamedKernelManager._GhostViewClass; }\n\n  /**\n   * ゴーストのビュークラス\n   * @type {cuttlebone}\n   */\n  set GhostViewClass(value) { this._GhostViewClass = value; }\n\n  /**\n   * load ghost\n   * @param {string} namedId - named id\n   * @param {GhostProfile} [profile] - profile\n   * @param {RoutableComponentRoutes} [routes] - ルーティング\n   * @param {Hash<GhostKernelController>} [controllers] - コントローラ\n   * @param {cuttlebone} [GhostViewClass] ghost view class\n   * @return {Promise<GhostKernel>} ghost kernel instance\n   */\n  async loadGhost(namedId, profile, routes, controllers, GhostViewClass) {\n    if (this.isKernelExists(namedId)) {\n      throw new Error(`ghost [${namedId}] already exists`);\n    }\n\n    const kernel = await this._getGhostKernelAsProfile(namedId, profile, routes, controllers, GhostViewClass);\n    this.registerKernel(namedId, kernel);\n    return kernel;\n  }\n\n  /**\n   * load ghost\n   * @param {string} namedId - named id\n   * @param {GhostProfile} [profile] - profile\n   */\n  async _get_ghost_profile(namedId, profile) {\n    return profile || await this.storage.ghost_profile(namedId);\n  }\n\n  /**\n   * load ghost\n   * @param {string} namedId - named id\n   * @param {GhostProfile} [profile] - profile\n   * @param {RoutableComponentRoutes} [routes] - ルーティング\n   * @param {Hash<GhostKernelController>} [controllers] - コントローラ\n   * @param {cuttlebone} [GhostViewClass] ghost view class\n   */\n  async _getGhostKernelAsProfile(namedId, profile, routes, controllers, GhostViewClass) {\n    const _profile = await this._get_ghost_profile(namedId, defaultProfile);\n    return await this._get_ghost_kernel(namedId, _profile.shell_name, _profile.balloon_name, routes, controllers, GhostViewClass);\n  }\n\n  /**\n   * build ghost kernel\n   * @param {string} namedId - named id\n   * @param {string} shellname - shellname\n   * @param {string} balloonname - balloonname\n   * @param {RoutableComponentRoutes} [routes] - ルーティング\n   * @param {Hash<GhostKernelController>} [controllers] - コントローラ\n   * @param {cuttlebone} [GhostViewClass] ghost view class\n   * @return {Promise<GhostKernel>} ghost kernel instance\n   */\n  async _get_ghost_kernel(namedId, shellname, balloonname, routes, controllers, GhostViewClass) {\n    return Promise.all([\n      this._get_ghost(namedId, storage),\n      this._get_shell(namedId, shellname, storage, GhostViewClass),\n      this._get_balloon(balloonname, storage, GhostViewClass),\n    ]).then(\n      ([shiori, shell, balloon]) => {\n        const shiorif = new Shiorif(shiori);\n        const named = namedmanager.materialize2(shell, balloon);\n        return new GhostKernel({\n          Shiorif: shiorif,\n          Named: named,\n          NamedKernelManager: this,\n          TimerEventSource: this.components.TimerEventSource,\n        }, routes, controllers);\n      }\n    )\n  }\n\n  /**\n   * ensure path separator at dirpath' end\n   * @param {string} dirpath - dirpath\n   * @return {string} dirpath that ends with path separator\n   */\n  static _canondirpath(dirpath) {\n    const path_separator = dirpath.match(/[\\\\\\/]/)[0];\n    return dirpath.replace(\n      new RegExp('\\\\' + path_separator + '?$'),\n      path_separator\n    );\n  }\n\n  /**\n   * get ghost(shiori) instance\n   * @param {string} namedId - named id\n   * @return {Promise<Shiori>} ghost(shiori) instance\n   */\n  async _get_ghost(namedId) {\n    this.emit('ghost_load', namedId);\n    const dirpath = NamedKernelManager._get_ghost_directory_path(namedId);\n    const ghost = await NamedKernelManager._load_ghost(storage.backend.fs, dirpath);\n    this.emit('ghost_loaded', namedId);\n    return ghost;\n  }\n\n  /**\n   * get ghost directory path\n   * @param {string} namedId - named id\n   * @return {string} ghost directory path\n   */\n  static _get_ghost_directory_path(namedId) {\n    return NamedKernelManager._canondirpath(this.storage.ghost_master_path(namedId));\n  }\n\n  /**\n   * load ghost(shiori)\n   * @param {NanikaDirectory} ghost directory contents\n   * @return {Promise<Shiori>} ghost(shiori) instance\n   */\n  static async _load_ghost(fs, dirpath) {\n    const shiori = await ShioriLoader.detect_shiori(fs, dirpath);\n    return await shiori.load(dirpath);\n  }\n\n  /**\n   * get shell instance\n   * @param {string} namedId - named id\n   * @param {string} shellname - shellname\n   * @param {cuttlebone} [GhostViewClass] ghost view class\n   * @return {Promise<Shell>} shell instance\n   */\n  async _get_shell(namedId, shellname, GhostViewClass) {\n    this.emit('load_shell_files', namedId, shellname);\n    const directory = await this._get_shell_directory(namedId, shellname);\n    this.emit('shell_load', namedId, shellname, directory);\n    const shell = await NamedKernelManager._load_shell(directory, GhostViewClass);\n    this.emit('shell_loaded', namedId, shellname, shell);\n    return shell;\n  }\n\n  /**\n   * get shell directory contents\n   * @param {string} namedId - named id\n   * @param {string} shellname - shellname\n   * @return {Promise<NanikaDirectory>} shell directory contents\n   */\n  async _get_shell_directory(namedId, shellname) {\n    return await this.storage.shell(namedId, shellname);\n  }\n\n  /**\n   * load shell\n   * @param {NanikaDirectory} shell directory contents\n   * @param {cuttlebone} [GhostViewClass] ghost view class\n   * @return {Promise<Shell>} shell instance\n   */\n  static _load_shell(directory, GhostViewClass = this.GhostViewClass) {\n    const shell = new GhostViewClass.Shell(directory.asArrayBuffer());\n    return shell.load();\n  }\n\n  /**\n   * get balloon instance\n   * @param {string} balloonname - balloonname\n   * @param {cuttlebone} [GhostViewClass] ghost view class\n   * @return {Promise<Balloon>} balloon instance\n   */\n  async _get_balloon(balloonname, GhostViewClass) {\n    this.emit('load_balloon_files', balloonname);\n    const directory = await this._get_balloon_directory(balloonname);\n    this.emit('balloon_load', balloonname, directory);\n    const balloon = await NamedKernelManager._load_balloon(directory, GhostViewClass);\n    this.emit('balloon_loaded', balloonname, shell);\n    return balloon;\n  }\n\n  /**\n   * get balloon directory contents\n   * @param {string} balloonname - balloonname\n   * @return {Promise<NanikaDirectory>} balloon directory contents\n   */\n  async _get_balloon_directory(balloonname) {\n    return await this.storage.balloon(balloonname);\n  }\n\n  /**\n   * load balloon\n   * @param {NanikaDirectory} balloon directory contents\n   * @param {cuttlebone} [GhostViewClass] ghost view class\n   * @return {Promise<Balloon>} balloon instance\n   */\n  static _load_balloon(directory, GhostViewClass = this.GhostViewClass) {\n    const balloon = new GhostViewClass.Balloon(directory.asArrayBuffer());\n    return balloon.load();\n  }\n\n  /**\n   * install named\n   * @param {Blob | URL | string} target install target resource (file, url or some)\n   * @param {NamedKernel | string} [from] who handled the target? kernel or named id\n   * @return {Promise}\n   */\n  async installNar(target, from = null) {\n    const nanikaStorage = this.components.NanikaStorage;\n    this.emit('install_begin', target);\n    let nar;\n    try {\n      if (target instanceof Blob) {\n        nar = await NarLoader.loadFromBlob(target);\n      } else if (target instanceof URL || target instanceof String || typeof target === 'string') {\n        nar = await NarLoader.loadFromURL(target);\n      } else {\n        throw new Error(`target is not Blob or URL : ${target.name || target}`); // TODO: typed error\n      }\n      this.emit('install_nar_loaded', target, nar);\n      const dirpath = typeof from === 'string' || from instanceof String ? from : this.namedId(from);\n      // TODO: fromの他形式対応\n      const sakuraname = nanikaStorage.ghost_descript(dirpath)['sakura.name']\n      const install_results = await nanikaStorage.install_nar(nar, dirpath, sakuraname);\n      if (!install_results) {\n        this.emit('install_not_accepted', target, nar);\n        return;\n      }\n      let ghost_result, balloon_result;\n      install_results.forEach((install_result) => {\n        if (install_result.type === 'ghost') {\n          ghost_result = install_result;\n        } else if (install_result.type === 'balloon') {\n          balloon_result = install_result;\n        }\n      });\n      if (ghost_result) {\n        // 初期profileを設定\n        // TODO: vanish回数など\n        const profile = await nanikaStorage.ghost_profile(ghost_result.directory);\n        if (!profile.shellname) profile.shellname = 'master';\n        if (!profile.balloonname) {\n          if (balloon_result) {\n            // 同梱バルーンを初期設定\n            profile.balloonname = balloon_result.directory;\n          } else {\n            profile.balloonname = 'origin'; // TODO: 設定を読む\n          }\n        }\n        await nanikaStorage.ghost_profile(ghost_result.directory, profile);\n      }\n      this.emit('install_succeed', target, nar);\n    } catch (error) {\n      this.emit('install_failure', error);\n      throw error;\n    }\n  }\n}\n\nmixin(NamedKernelManager, NamedKernelManagerGhostModule);\n\n/**\n * マネージャ用のコントローラ\n * @implements {RoutableComponentController}\n */\nexport class NamedKernelManagerController {\n  /**\n   * コンストラクタ\n   * @param {NamedKernelManager} manager マネージャ\n   */\n  constructor(manager) {\n    this._manager = manager;\n  }\n\n  /**\n   * マネージャ\n   * @type {NamedKernelManager}\n   */\n  get manager() { return this._manager; }\n}\n"]}